<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>RubiksWord</title>
  <style>
  body {
    background-color: #1e1e1e;
    color: white;
    font-family: sans-serif;
    text-align: center;
    padding: 20px;
    margin: 0;
  }

  .center-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
  }

  .game-container {
    display: grid;
    grid-template-columns: repeat(7, 1fr);
    grid-template-rows: repeat(7, 1fr);
    gap: 1vw;
    max-width: 90vw;
    max-height: 90vw;
  }

  .cell, .btn {
    width: 12vw;
    height: 12vw;
    max-width: 60px;
    max-height: 60px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 5vw;
    font-weight: bold;
    border-radius: 6px;
    transition: transform 0.3s;
  }

  .cell {
    background-color: #333;
    border: 2px solid #555;
  }

  .btn {
    background-color: #444;
    color: white;
    border: none;
    cursor: pointer;
    font-weight: bold;
    transition: background 0.2s;
  }

  .empty {
    background: transparent;
  }

  #moves {
    margin-top: 20px;
    font-size: 1.2em;
  }

  #newGameBtn {
    background-color: green;
    margin-top: 20px;
    padding: 1em 2em;
    font-size: 1.5em;
    min-width: 180px;
  }

  /* Animation classes */
  .slide-right { animation: slideRight 0.3s; }
  .slide-left { animation: slideLeft 0.3s; }
  .slide-up { animation: slideUp 0.3s; }
  .slide-down { animation: slideDown 0.3s; }

  @keyframes slideRight {
    0% { transform: translateX(0); }
    100% { transform: translateX(65px); }
  }
  @keyframes slideLeft {
    0% { transform: translateX(0); }
    100% { transform: translateX(-65px); }
  }
  @keyframes slideDown {
    0% { transform: translateY(0); }
    100% { transform: translateY(65px); }
  }
  @keyframes slideUp {
    0% { transform: translateY(0); }
    100% { transform: translateY(-65px); }
  }

  /* Media Queries for larger screens */
  @media (min-width: 768px) {
    .cell, .btn {
      width: 50px;
      height: 50px;
      font-size: 20px;
    }
  }

  @media (min-width: 1024px) {
    .game-container {
      gap: 6px;
      max-width: none;
      max-height: none;
    }
    .cell, .btn {
      width: 60px;
      height: 60px;
      font-size: 24px;
    }
  }
</style>

</head>
<body>
  <h1>RubiksWord!</h1>
  <p>The grid below contains five 5-letter words horizontally.</p>
  <p>Use the arrows to rotate rows and columns!</p>
  <div class="center-container">
    <div class="game-container" id="game"></div>
    <p id="moves">Moves: 0</p>
    <button class="btn" id="newGameBtn">New Game</button>
  </div>

  <script>
    const words = ["ABACK","ABASE","ABATE","ABBEY","ABBOT","ABETS","ABHOR","ABIDE","ABODE","ABORT","ABOUT","ABOVE","ABUSE","ABYSS","ACHED","ACING","ACORN","ACRID","ACTED","ACTOR","ACUTE","ADAGE",
                   "BABEL","BACON","BADDY","BADGE","BADLY","BAGEL","BAGGY","BAIRN","BAIZE","BAKED","BAKER","BALDY","BALED","BALER","BALMY","BALSA","BANAL","BANDY","BANJO","BARED","BARER","BARGE",
                   "CABAL","CABBY","CABER","CABIN","CABLE","CACHE","CACTI","CADDY","CADET","CADRE","CAGED","CAGEY","CAIRN","CAKED","CALVE","CAMEL","CAMEO","CANAL","CANDY","CANED","CANNY","CANOE",
                   "DACHA","DADDY","DAFFY","DAILY","DAIRY","DAISY","DANCE","DANDY","DARED","DATED","DATER","DATUM","DAUNT","DAZED","DEALT","DEATH","DEBIT","DEBUG","DEBUT","DECAF","DECAL","DECAY",
                   "EAGER","EAGLE","EARED","EARLY","EARTH","EASED","EASEL","EASER","EATEN","EATER","EBBED","EBONY","EBOOK","ECLAT","EDEMA","EDGED","EDGER","EDICT","EDIFY","EERIE","EGGED","EGRET",
                   "FABLE","FACED","FACER","FACET","FACIA","FADED","FADER","FAERY","FAINT","FAIRY","FAITH","FAKED","FAKER","FAMED","FANCY","FARCE","FARED","FATAL","FATED","FATTY","FAULT","FAUNA",
                   "GAMMA","GAUGE","GENRE","GHOST","GIANT","GIVEN","GLAND","GLASS","GLOBE","GLORY","GLOSS","GLOVE","GLUED","GOING","GRACE","GRADE","GRAIN","GRAND","GRANT","GRAPE","GRAPH","GRASP",
                   "HABIT","HANDY","HAPPY","HARSH","HATED","HAVEN","HEARD","HEART","HEAVY","HEDGE","HELLO","HENCE","HIRED","HOBBY","HOLLY","HONEY","HONOR","HOPED","HORSE","HOTEL","HOUSE","HOVER",
                   "IDEAL","IDIOT","IMAGE","IMPLY","INBOX","INCUR","INDEX","INDIE","INNER","INPUT","INTRO","ISSUE",
                   "JELLY","JEWEL","JOINT","JUDGE","JUICE","JUICY",
                   "KNIFE","KNOCK","KNOWN",
                   "LABEL","LABOR","LARGE","LASER","LATER","LAUGH","LAYER","LEARN","LEASE","LEAST","LEAVE","LEGAL","LEMON","LEVEL","LEVER","LIGHT","LIKED","LIMIT","LINED","LINEN","LINER","LIVED",
                   "MACRO","MAGIC","MAJOR","MAKER","MAPLE","MARCH","MARRY","MATCH","MATTE","MAYBE","MAYOR","MEANT","MEDAL","MEDIA","MELEE","MERCY","MERGE","MERIT","MERRY","MESSY","METAL","METER",
                   "NAKED","NAMED","NASAL","NASTY","NAVAL","NERVE","NEVER","NEWER","NEWLY","NEXUS","NICER","NICHE","NIGHT","NINJA","NINTH","NOBLE","NOISE","NOISY","NORTH","NOTCH","NOTED","NOVEL",
                   "OASIS","OCCUR","OCEAN","OFFER","OFTEN","OLDER","OLIVE","OMEGA","ONION","ONSET","OPERA","OPTED","OPTIC","ORBIT","ORDER","ORGAN","OTHER","OUGHT","OUNCE","OUTER","OWNED","OWNER",
                   "PAINT","PANEL","PANIC","PAPER","PARTY","PASTA","PASTE","PATCH","PATIO","PAUSE","PEACE","PEACH","PEARL","PEDAL","PENNY","PETTY","PHASE","PHONE","PHOTO","PIANO","PIECE","PILOT",
                   "QUEEN","QUERY","QUEST","QUEUE","QUICK","QUIET","QUILT","QUITE","QUOTE",
                   "RADAR","RADIO","RAINY","RAISE","RALLY","RANCH","RANGE","RAPID","RATED","RATIO","RAZOR","REACH","REACT","READY","REALM","REBEL","REFER","REIGN","RELAX","RELAY","RENAL","RENEW",
                   "SADLY","SAFER","SALAD","SALON","SANDY","SATIN","SAUCE","SAVED","SCALE","SCALP","SCARE","SCARF","SCARY","SCENE","SCENT","SCOOP","SCOPE","SCORE","SCOUT","SCRAP","SCREW","SENSE",
                   "TABLE","TAKEN","TASTE","TASTY","TEACH","TEETH","TEMPO","TENTH","THANK","THEFT","THEIR","THEME","THERE","THESE","THICK","THIEF","THIGH","THING","THINK","THIRD","THOSE","THREE",
                   "ULTRA","UNCLE","UNDER","UNION","UNITE","UNITY","UNTIL","UPPER","UPSET","URBAN","URGED","URINE","USAGE","USING","USUAL",
                   "VAGUE","VALID","VALUE","VALVE","VAPOR","VAULT","VEGAN","VENUE","VERSE","VIDEO","VILLA","VINYL","VIRAL","VIRUS","VISIT","VITAL","VIVID","VOCAL","VODKA","VOICE","VOTED","VOTER",
                   "WAGON","WAIST","WASTE","WATCH","WATER","WEIGH","WEIRD","WELSH","WHALE","WHEAT","WHEEL","WHERE","WHICH","WHILE","WHITE","WHOLE","WHOSE","WIDER","WIDOW","WIDTH","WIPED","WIRED",
                   "YACHT","YEAST","YIELD","YOUNG","YOUTH","YUMMY",
    ];

    // COLORS FOR EACH WORD (ROW)
    const wordColors = ["#e74c3c", "#f1c40f", "#2ecc71", "#3498db", "#9b59b6"]; // 5 distinct colors

    function pickRandomWords(wordList, count) {
      const shuffled = [...wordList].sort(() => Math.random() - 0.5);
      return shuffled.slice(0, count);
    }

    let selectedWords = pickRandomWords(words, 5);
    let originalGrid = selectedWords.map(w => w.split(""));
    let grid = JSON.parse(JSON.stringify(originalGrid));
    let moves = 0;

    // Track original row for each tile (color origin)
    let originRows = Array.from({length: 5}, (_, r) => Array(5).fill(r));

    // SCRAMBLE FUNCTION (scramble grid and originRows in parallel)
    function scramble() {
      selectedWords = pickRandomWords(words, 5);
      originalGrid = selectedWords.map(w => w.split(""));
      grid = JSON.parse(JSON.stringify(originalGrid));
      originRows = Array.from({length: 5}, (_, r) => Array(5).fill(r));
      for (let i = 0; i < 15; i++) {
        const r = Math.floor(Math.random() * 5);
        const c = Math.floor(Math.random() * 5);
        if (Math.random() > 0.5) {
          rotateRowRight(r, true);
        } else {
          rotateRowLeft(r, true);
        }
        if (Math.random() > 0.5) {
          rotateColDown(c, true);
        } else {
          rotateColUp(c, true);
        }
      }
      moves = 0;
      update();
    }

    // ROTATION FUNCTIONS (move grid and originRows in parallel)
    function rotateRowRight(row, isScramble) {
      const last = grid[row][4];
      const lastOrigin = originRows[row][4];
      for (let i = 4; i > 0; i--) {
        grid[row][i] = grid[row][i - 1];
        originRows[row][i] = originRows[row][i - 1];
      }
      grid[row][0] = last;
      originRows[row][0] = lastOrigin;
      if (!isScramble) moves++;
    }

    function rotateRowLeft(row, isScramble) {
      const first = grid[row][0];
      const firstOrigin = originRows[row][0];
      for (let i = 0; i < 4; i++) {
        grid[row][i] = grid[row][i + 1];
        originRows[row][i] = originRows[row][i + 1];
      }
      grid[row][4] = first;
      originRows[row][4] = firstOrigin;
      if (!isScramble) moves++;
    }

    function rotateColDown(col, isScramble) {
      const last = grid[4][col];
      const lastOrigin = originRows[4][col];
      for (let i = 4; i > 0; i--) {
        grid[i][col] = grid[i - 1][col];
        originRows[i][col] = originRows[i - 1][col];
      }
      grid[0][col] = last;
      originRows[0][col] = lastOrigin;
      if (!isScramble) moves++;
    }

    function rotateColUp(col, isScramble) {
      const first = grid[0][col];
      const firstOrigin = originRows[0][col];
      for (let i = 0; i < 4; i++) {
        grid[i][col] = grid[i + 1][col];
        originRows[i][col] = originRows[i + 1][col];
      }
      grid[4][col] = first;
      originRows[4][col] = firstOrigin;
      if (!isScramble) moves++;
    }

    // ANIMATION WRAPPERS
    function animateRow(row, direction) {
      const cells = document.querySelectorAll(`.cell[data-row='${row}']`);
      cells.forEach(cell => {
        cell.classList.add(direction === "right" ? "slide-right" : "slide-left");
      });
      setTimeout(() => {
        direction === "right" ? rotateRowRight(row) : rotateRowLeft(row);
        update();
      }, 300);
    }
    function animateCol(col, direction) {
      const cells = document.querySelectorAll(`.cell[data-col='${col}']`);
      cells.forEach(cell => {
        cell.classList.add(direction === "down" ? "slide-down" : "slide-up");
      });
      setTimeout(() => {
        direction === "down" ? rotateColDown(col) : rotateColUp(col);
        update();
      }, 300);
    }

    // CREATE GRID (use originRows to color tiles)
    function createGrid() {
      game.innerHTML = "";
      for (let row = 0; row < 7; row++) {
        for (let col = 0; col < 7; col++) {
          if (row === 0 && col >= 1 && col <= 5) {
            addButton("â†‘", () => animateCol(col - 1, "up"));
          } else if (row === 6 && col >= 1 && col <= 5) {
            addButton("â†“", () => animateCol(col - 1, "down"));
          } else if (col === 0 && row >= 1 && row <= 5) {
            addButton("â†", () => animateRow(row - 1, "left"), wordColors[row - 1]);
          } else if (col === 6 && row >= 1 && row <= 5) {
            addButton("â†’", () => animateRow(row - 1, "right"), wordColors[row - 1]);
          } else if (row >= 1 && row <= 5 && col >= 1 && col <= 5) {
            const div = document.createElement("div");
            div.className = "cell";
            div.dataset.row = row - 1;
            div.dataset.col = col - 1;
            const char = grid[row - 1][col - 1];
            div.textContent = char;
            // Color from the original row of the tile
            const colorIdx = originRows[row - 1][col - 1];
            const bgColor = wordColors[colorIdx];
            div.style.backgroundColor = bgColor;
            div.style.color = (bgColor === "#f1c40f") ? "#222" : "white";
            div.style.border = "2px solid #555";
            game.appendChild(div);
          } else {
            const div = document.createElement("div");
            div.className = "cell empty";
            game.appendChild(div);
          }
        }
      }
    }

    // ADD COLOR ARGUMENT TO BUTTONS
    function addButton(symbol, action, color) {
      const btn = document.createElement("button");
      btn.className = "btn";
      btn.textContent = symbol;
      btn.onclick = action;
      if (color) {
        btn.style.backgroundColor = color;
        if (color === "#f1c40f") btn.style.color = "#222";
        else btn.style.color = "white";
      }
      game.appendChild(btn);
    }

    function update() {
      createGrid();
      movesEl.textContent = `Moves: ${moves}`;
      checkWin();
    }

    function checkWin() {
      const won = grid.every((row, i) => row.join("") === originalGrid[i].join(""));
      if (won) {
        let feedback = "";
        if (moves < 100)
          feedback = "You are a GENIUS!";
        else if (moves < 150)
          feedback = "You are a VERY SMART PERSON!";
        else if (moves < 200)
          feedback = "You are a SMART PERSON!";
        else if (moves < 300)
          feedback = "You are DEEPLY AVERAGE!";
        else
          feedback = "Wow you showed great commitment there!";

        setTimeout(() => alert(`ðŸŽ‰ You solved it in ${moves} moves!\n${feedback}`), 100);
      }
    }

    window.addEventListener("DOMContentLoaded", () => {
      scramble();
    });

    newGameBtn.onclick = scramble;
  </script>
</body>
</html>
